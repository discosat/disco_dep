/* automatically generated by rust-bindgen 0.64.0 */

pub const CSP_ERR_NONE: u32 = 0;
pub const CSP_ERR_NOMEM: i32 = -1;
pub const CSP_ERR_INVAL: i32 = -2;
pub const CSP_ERR_TIMEDOUT: i32 = -3;
pub const CSP_ERR_USED: i32 = -4;
pub const CSP_ERR_NOTSUP: i32 = -5;
pub const CSP_ERR_BUSY: i32 = -6;
pub const CSP_ERR_ALREADY: i32 = -7;
pub const CSP_ERR_RESET: i32 = -8;
pub const CSP_ERR_NOBUFS: i32 = -9;
pub const CSP_ERR_TX: i32 = -10;
pub const CSP_ERR_DRIVER: i32 = -11;
pub const CSP_ERR_AGAIN: i32 = -12;
pub const CSP_ERR_NOSYS: i32 = -38;
pub const CSP_ERR_HMAC: i32 = -100;
pub const CSP_ERR_CRC32: i32 = -102;
pub const CSP_ERR_SFP: i32 = -103;
pub const CSP_BUFFER_COUNT: u32 = 1000;
pub const CSP_BUFFER_SIZE: u32 = 2048;
pub const CSP_CONN_MAX: u32 = 20;
pub const CSP_CONN_RXQUEUE_LEN: u32 = 1000;
pub const CSP_ENABLE_CSP_PRINT: u32 = 1;
pub const CSP_HAVE_LIBSOCKETCAN: u32 = 1;
pub const CSP_HAVE_LIBZMQ: u32 = 1;
pub const CSP_HAVE_STDIO: u32 = 1;
pub const CSP_PORT_MAX_BIND: u32 = 16;
pub const CSP_POSIX: u32 = 1;
pub const CSP_PRINT_STDIO: u32 = 1;
pub const CSP_QFIFO_LEN: u32 = 1000;
pub const CSP_RDP_MAX_WINDOW: u32 = 1000;
pub const CSP_RTABLE_SIZE: u32 = 10;
pub const CSP_USE_DEDUP: u32 = 1;
pub const CSP_USE_HMAC: u32 = 1;
pub const CSP_USE_PROMISC: u32 = 1;
pub const CSP_USE_RDP: u32 = 1;
pub const _INTTYPES_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 35;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const ____gwchar_t_defined: u32 = 1;
pub const __PRI64_PREFIX: &[u8; 2usize] = b"l\0";
pub const __PRIPTR_PREFIX: &[u8; 2usize] = b"l\0";
pub const PRId8: &[u8; 2usize] = b"d\0";
pub const PRId16: &[u8; 2usize] = b"d\0";
pub const PRId32: &[u8; 2usize] = b"d\0";
pub const PRId64: &[u8; 3usize] = b"ld\0";
pub const PRIdLEAST8: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST16: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST32: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST8: &[u8; 2usize] = b"d\0";
pub const PRIdFAST16: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST32: &[u8; 3usize] = b"ld\0";
pub const PRIdFAST64: &[u8; 3usize] = b"ld\0";
pub const PRIi8: &[u8; 2usize] = b"i\0";
pub const PRIi16: &[u8; 2usize] = b"i\0";
pub const PRIi32: &[u8; 2usize] = b"i\0";
pub const PRIi64: &[u8; 3usize] = b"li\0";
pub const PRIiLEAST8: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST16: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST32: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &[u8; 3usize] = b"li\0";
pub const PRIiFAST8: &[u8; 2usize] = b"i\0";
pub const PRIiFAST16: &[u8; 3usize] = b"li\0";
pub const PRIiFAST32: &[u8; 3usize] = b"li\0";
pub const PRIiFAST64: &[u8; 3usize] = b"li\0";
pub const PRIo8: &[u8; 2usize] = b"o\0";
pub const PRIo16: &[u8; 2usize] = b"o\0";
pub const PRIo32: &[u8; 2usize] = b"o\0";
pub const PRIo64: &[u8; 3usize] = b"lo\0";
pub const PRIoLEAST8: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST16: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST32: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST8: &[u8; 2usize] = b"o\0";
pub const PRIoFAST16: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST32: &[u8; 3usize] = b"lo\0";
pub const PRIoFAST64: &[u8; 3usize] = b"lo\0";
pub const PRIu8: &[u8; 2usize] = b"u\0";
pub const PRIu16: &[u8; 2usize] = b"u\0";
pub const PRIu32: &[u8; 2usize] = b"u\0";
pub const PRIu64: &[u8; 3usize] = b"lu\0";
pub const PRIuLEAST8: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST16: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST32: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST8: &[u8; 2usize] = b"u\0";
pub const PRIuFAST16: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST32: &[u8; 3usize] = b"lu\0";
pub const PRIuFAST64: &[u8; 3usize] = b"lu\0";
pub const PRIx8: &[u8; 2usize] = b"x\0";
pub const PRIx16: &[u8; 2usize] = b"x\0";
pub const PRIx32: &[u8; 2usize] = b"x\0";
pub const PRIx64: &[u8; 3usize] = b"lx\0";
pub const PRIxLEAST8: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST16: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST32: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST8: &[u8; 2usize] = b"x\0";
pub const PRIxFAST16: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST32: &[u8; 3usize] = b"lx\0";
pub const PRIxFAST64: &[u8; 3usize] = b"lx\0";
pub const PRIX8: &[u8; 2usize] = b"X\0";
pub const PRIX16: &[u8; 2usize] = b"X\0";
pub const PRIX32: &[u8; 2usize] = b"X\0";
pub const PRIX64: &[u8; 3usize] = b"lX\0";
pub const PRIXLEAST8: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST16: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST32: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST8: &[u8; 2usize] = b"X\0";
pub const PRIXFAST16: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST32: &[u8; 3usize] = b"lX\0";
pub const PRIXFAST64: &[u8; 3usize] = b"lX\0";
pub const PRIdMAX: &[u8; 3usize] = b"ld\0";
pub const PRIiMAX: &[u8; 3usize] = b"li\0";
pub const PRIoMAX: &[u8; 3usize] = b"lo\0";
pub const PRIuMAX: &[u8; 3usize] = b"lu\0";
pub const PRIxMAX: &[u8; 3usize] = b"lx\0";
pub const PRIXMAX: &[u8; 3usize] = b"lX\0";
pub const PRIdPTR: &[u8; 3usize] = b"ld\0";
pub const PRIiPTR: &[u8; 3usize] = b"li\0";
pub const PRIoPTR: &[u8; 3usize] = b"lo\0";
pub const PRIuPTR: &[u8; 3usize] = b"lu\0";
pub const PRIxPTR: &[u8; 3usize] = b"lx\0";
pub const PRIXPTR: &[u8; 3usize] = b"lX\0";
pub const SCNd8: &[u8; 4usize] = b"hhd\0";
pub const SCNd16: &[u8; 3usize] = b"hd\0";
pub const SCNd32: &[u8; 2usize] = b"d\0";
pub const SCNd64: &[u8; 3usize] = b"ld\0";
pub const SCNdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST32: &[u8; 3usize] = b"ld\0";
pub const SCNdFAST64: &[u8; 3usize] = b"ld\0";
pub const SCNi8: &[u8; 4usize] = b"hhi\0";
pub const SCNi16: &[u8; 3usize] = b"hi\0";
pub const SCNi32: &[u8; 2usize] = b"i\0";
pub const SCNi64: &[u8; 3usize] = b"li\0";
pub const SCNiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &[u8; 3usize] = b"li\0";
pub const SCNiFAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &[u8; 3usize] = b"li\0";
pub const SCNiFAST32: &[u8; 3usize] = b"li\0";
pub const SCNiFAST64: &[u8; 3usize] = b"li\0";
pub const SCNu8: &[u8; 4usize] = b"hhu\0";
pub const SCNu16: &[u8; 3usize] = b"hu\0";
pub const SCNu32: &[u8; 2usize] = b"u\0";
pub const SCNu64: &[u8; 3usize] = b"lu\0";
pub const SCNuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST32: &[u8; 3usize] = b"lu\0";
pub const SCNuFAST64: &[u8; 3usize] = b"lu\0";
pub const SCNo8: &[u8; 4usize] = b"hho\0";
pub const SCNo16: &[u8; 3usize] = b"ho\0";
pub const SCNo32: &[u8; 2usize] = b"o\0";
pub const SCNo64: &[u8; 3usize] = b"lo\0";
pub const SCNoLEAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST32: &[u8; 3usize] = b"lo\0";
pub const SCNoFAST64: &[u8; 3usize] = b"lo\0";
pub const SCNx8: &[u8; 4usize] = b"hhx\0";
pub const SCNx16: &[u8; 3usize] = b"hx\0";
pub const SCNx32: &[u8; 2usize] = b"x\0";
pub const SCNx64: &[u8; 3usize] = b"lx\0";
pub const SCNxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST32: &[u8; 3usize] = b"lx\0";
pub const SCNxFAST64: &[u8; 3usize] = b"lx\0";
pub const SCNdMAX: &[u8; 3usize] = b"ld\0";
pub const SCNiMAX: &[u8; 3usize] = b"li\0";
pub const SCNoMAX: &[u8; 3usize] = b"lo\0";
pub const SCNuMAX: &[u8; 3usize] = b"lu\0";
pub const SCNxMAX: &[u8; 3usize] = b"lx\0";
pub const SCNdPTR: &[u8; 3usize] = b"ld\0";
pub const SCNiPTR: &[u8; 3usize] = b"li\0";
pub const SCNoPTR: &[u8; 3usize] = b"lo\0";
pub const SCNuPTR: &[u8; 3usize] = b"lu\0";
pub const SCNxPTR: &[u8; 3usize] = b"lx\0";
pub const CSP_DBG_ERR_CORRUPT_BUFFER: u32 = 1;
pub const CSP_DBG_ERR_MTU_EXCEEDED: u32 = 2;
pub const CSP_DBG_ERR_ALREADY_FREE: u32 = 3;
pub const CSP_DBG_ERR_REFCOUNT: u32 = 4;
pub const CSP_DBG_ERR_INVALID_RTABLE_ENTRY: u32 = 6;
pub const CSP_DBG_ERR_UNSUPPORTED: u32 = 7;
pub const CSP_DBG_ERR_INVALID_BIND_PORT: u32 = 8;
pub const CSP_DBG_ERR_PORT_ALREADY_IN_USE: u32 = 9;
pub const CSP_DBG_ERR_ALREADY_CLOSED: u32 = 10;
pub const CSP_DBG_ERR_INVALID_POINTER: u32 = 11;
pub const CSP_DBG_ERR_CLOCK_SET_FAIL: u32 = 12;
pub const CSP_DBG_CAN_ERR_FRAME_LOST: u32 = 1;
pub const CSP_DBG_CAN_ERR_RX_OVF: u32 = 2;
pub const CSP_DBG_CAN_ERR_RX_OUT: u32 = 3;
pub const CSP_DBG_CAN_ERR_SHORT_BEGIN: u32 = 4;
pub const CSP_DBG_CAN_ERR_INCOMPLETE: u32 = 5;
pub const CSP_DBG_CAN_ERR_UNKNOWN: u32 = 6;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const CSP_QUEUE_OK: u32 = 0;
pub const CSP_QUEUE_ERROR: i32 = -1;
pub const CSP_ANY: u32 = 255;
pub const CSP_FRES1: u32 = 128;
pub const CSP_FRES2: u32 = 64;
pub const CSP_FRES3: u32 = 32;
pub const CSP_FFRAG: u32 = 16;
pub const CSP_FHMAC: u32 = 8;
pub const CSP_FRDP: u32 = 2;
pub const CSP_FCRC32: u32 = 1;
pub const CSP_SO_NONE: u32 = 0;
pub const CSP_SO_RDPREQ: u32 = 1;
pub const CSP_SO_RDPPROHIB: u32 = 2;
pub const CSP_SO_HMACREQ: u32 = 4;
pub const CSP_SO_HMACPROHIB: u32 = 8;
pub const CSP_SO_CRC32REQ: u32 = 64;
pub const CSP_SO_CRC32PROHIB: u32 = 128;
pub const CSP_SO_CONN_LESS: u32 = 256;
pub const CSP_SO_SAME: u32 = 32768;
pub const CSP_O_NONE: u32 = 0;
pub const CSP_O_RDP: u32 = 1;
pub const CSP_O_NORDP: u32 = 2;
pub const CSP_O_HMAC: u32 = 4;
pub const CSP_O_NOHMAC: u32 = 8;
pub const CSP_O_CRC32: u32 = 64;
pub const CSP_O_NOCRC32: u32 = 128;
pub const CSP_O_SAME: u32 = 32768;
pub const CSP_PACKET_PADDING_BYTES: u32 = 8;
pub const CSP_RDP_HEADER_SIZE: u32 = 5;
pub const CSP_HOSTNAME_LEN: u32 = 20;
pub const CSP_MODEL_LEN: u32 = 30;
pub const CSP_REBOOT_MAGIC: u32 = 2147975175;
pub const CSP_REBOOT_SHUTDOWN_MAGIC: u32 = 3521467034;
pub const CSP_IFLIST_NAME_MAX: u32 = 10;
pub const CSP_NO_VIA_ADDRESS: u32 = 65535;
pub const _STRING_H: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const _STRINGS_H: u32 = 1;
pub const _MALLOC_H: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const M_MXFAST: u32 = 1;
pub const M_NLBLKS: u32 = 2;
pub const M_GRAIN: u32 = 3;
pub const M_KEEP: u32 = 4;
pub const M_TRIM_THRESHOLD: i32 = -1;
pub const M_TOP_PAD: i32 = -2;
pub const M_MMAP_THRESHOLD: i32 = -3;
pub const M_MMAP_MAX: i32 = -4;
pub const M_CHECK_ACTION: i32 = -5;
pub const M_PERTURB: i32 = -6;
pub const M_ARENA_TEST: i32 = -7;
pub const M_ARENA_MAX: i32 = -8;
pub const CSP_MAX_TIMEOUT: u32 = 4294967295;
pub const CSP_MAX_DELAY: u32 = 4294967295;
pub const CSP_INFINITY: u32 = 4294967295;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __gwchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<imaxdiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxabs(__n: intmax_t) -> intmax_t;
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const __gwchar_t,
        __endptr: *mut *mut __gwchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    #[doc = " Error counters"]
    pub static mut csp_dbg_buffer_out: u8;
}
extern "C" {
    pub static mut csp_dbg_conn_out: u8;
}
extern "C" {
    pub static mut csp_dbg_conn_ovf: u8;
}
extern "C" {
    pub static mut csp_dbg_conn_noroute: u8;
}
extern "C" {
    pub static mut csp_dbg_inval_reply: u8;
}
extern "C" {
    pub static mut csp_dbg_errno: u8;
}
extern "C" {
    pub static mut csp_dbg_can_errno: u8;
}
extern "C" {
    pub static mut csp_dbg_rdp_print: u8;
}
extern "C" {
    pub static mut csp_dbg_packet_print: u8;
}
extern "C" {
    pub fn csp_print_func(fmt: *const ::std::os::raw::c_char, ...);
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type csp_queue_handle_t = *mut ::std::os::raw::c_void;
pub type csp_static_queue_t = *mut ::std::os::raw::c_void;
extern "C" {
    pub fn csp_queue_create_static(
        length: ::std::os::raw::c_int,
        item_size: usize,
        buffer: *mut ::std::os::raw::c_char,
        queue: *mut csp_static_queue_t,
    ) -> csp_queue_handle_t;
}
extern "C" {
    #[doc = "Enqueue (back) value.\n@param[in] handle queue.\n@param[in] value value to add (by copy)\n@param[in] timeout timeout, time to wait for free space\n@return #CSP_QUEUE_OK on success, otherwise a queue error code."]
    pub fn csp_queue_enqueue(
        handle: csp_queue_handle_t,
        value: *const ::std::os::raw::c_void,
        timeout: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Enqueue (back) value from ISR.\n@param[in] handle queue.\n@param[in] value value to add (by copy)\n@param[out] pxTaskWoken Valid reference if called from ISR, otherwise NULL!\n@return #CSP_QUEUE_OK on success, otherwise a queue error code."]
    pub fn csp_queue_enqueue_isr(
        handle: csp_queue_handle_t,
        value: *const ::std::os::raw::c_void,
        pxTaskWoken: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Dequeue value (front).\n@param[in] handle queue.\n@param[out] buf extracted element (by copy).\n@param[in] timeout timeout, time to wait for element in queue.\n@return #CSP_QUEUE_OK on success, otherwise a queue error code."]
    pub fn csp_queue_dequeue(
        handle: csp_queue_handle_t,
        buf: *mut ::std::os::raw::c_void,
        timeout: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Dequeue value (front) from ISR.\n@param[in] handle queue.\n@param[out] buf extracted element (by copy).\n@param[out] pxTaskWoken Valid reference if called from ISR, otherwise NULL!\n@return #CSP_QUEUE_OK on success, otherwise a queue error code."]
    pub fn csp_queue_dequeue_isr(
        handle: csp_queue_handle_t,
        buf: *mut ::std::os::raw::c_void,
        pxTaskWoken: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Queue size.\n@param[in] handle queue.\n@return Number of elements in the queue."]
    pub fn csp_queue_size(handle: csp_queue_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Queue size from ISR.\n@param[in] handle queue.\n@return Number of elements in the queue."]
    pub fn csp_queue_size_isr(handle: csp_queue_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn csp_queue_free(handle: csp_queue_handle_t) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct csp_timestamp_t {
    pub tv_sec: u32,
    pub tv_nsec: u32,
}
#[test]
fn bindgen_test_layout_csp_timestamp_t() {
    const UNINIT: ::std::mem::MaybeUninit<csp_timestamp_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<csp_timestamp_t>(),
        8usize,
        concat!("Size of: ", stringify!(csp_timestamp_t))
    );
    assert_eq!(
        ::std::mem::align_of::<csp_timestamp_t>(),
        4usize,
        concat!("Alignment of ", stringify!(csp_timestamp_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_timestamp_t),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_timestamp_t),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[doc = "!< CSP management, e.g. memory, routes, stats"]
pub const csp_service_port_t_CSP_CMP: csp_service_port_t = 0;
#[doc = "!< Ping - return ping"]
pub const csp_service_port_t_CSP_PING: csp_service_port_t = 1;
#[doc = "!< Current process list"]
pub const csp_service_port_t_CSP_PS: csp_service_port_t = 2;
#[doc = "!< Free memory"]
pub const csp_service_port_t_CSP_MEMFREE: csp_service_port_t = 3;
#[doc = "!< Reboot, see #CSP_REBOOT_MAGIC and #CSP_REBOOT_SHUTDOWN_MAGIC"]
pub const csp_service_port_t_CSP_REBOOT: csp_service_port_t = 4;
#[doc = "!< Free CSP buffers"]
pub const csp_service_port_t_CSP_BUF_FREE: csp_service_port_t = 5;
#[doc = "!< Uptime"]
pub const csp_service_port_t_CSP_UPTIME: csp_service_port_t = 6;
#[doc = "Reserved ports for CSP services."]
pub type csp_service_port_t = ::std::os::raw::c_uint;
#[doc = "!< Critical"]
pub const csp_prio_t_CSP_PRIO_CRITICAL: csp_prio_t = 0;
#[doc = "!< High"]
pub const csp_prio_t_CSP_PRIO_HIGH: csp_prio_t = 1;
#[doc = "!< Normal (default)"]
pub const csp_prio_t_CSP_PRIO_NORM: csp_prio_t = 2;
#[doc = "!< Low"]
pub const csp_prio_t_CSP_PRIO_LOW: csp_prio_t = 3;
#[doc = "Message priority."]
pub type csp_prio_t = ::std::os::raw::c_uint;
#[doc = "CSP identifier/header."]
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct csp_id_t {
    pub pri: u8,
    pub flags: u8,
    pub src: u16,
    pub dst: u16,
    pub dport: u8,
    pub sport: u8,
}
#[test]
fn bindgen_test_layout_csp_id_t() {
    const UNINIT: ::std::mem::MaybeUninit<csp_id_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<csp_id_t>(),
        8usize,
        concat!("Size of: ", stringify!(csp_id_t))
    );
    assert_eq!(
        ::std::mem::align_of::<csp_id_t>(),
        1usize,
        concat!("Alignment of ", stringify!(csp_id_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pri) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_id_t),
            "::",
            stringify!(pri)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_id_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).src) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_id_t),
            "::",
            stringify!(src)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dst) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_id_t),
            "::",
            stringify!(dst)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dport) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_id_t),
            "::",
            stringify!(dport)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sport) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_id_t),
            "::",
            stringify!(sport)
        )
    );
}
#[doc = "CSP Packet.\n\nThis structure is constructed to fit with all interface and protocols to prevent the\nneed to copy data (zero copy).\n\n@note In most cases a CSP packet cannot be reused in case of send failure, because the\nlower layers may add additional data causing increased length (e.g. CRC32), convert\nthe CSP id to different endian (e.g. I2C), etc."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct csp_packet_s {
    pub __bindgen_anon_1: csp_packet_s__bindgen_ty_1,
    pub length: u16,
    pub id: csp_id_t,
    pub next: *mut csp_packet_s,
    pub header: [u8; 8usize],
    pub __bindgen_anon_2: csp_packet_s__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union csp_packet_s__bindgen_ty_1 {
    pub __bindgen_anon_1: csp_packet_s__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: csp_packet_s__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct csp_packet_s__bindgen_ty_1__bindgen_ty_1 {
    pub rdp_quarantine: u32,
    pub timestamp_tx: u32,
    pub timestamp_rx: u32,
    pub conn: *mut csp_conn_s,
}
#[test]
fn bindgen_test_layout_csp_packet_s__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<csp_packet_s__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<csp_packet_s__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(csp_packet_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<csp_packet_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(csp_packet_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rdp_quarantine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(rdp_quarantine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp_tx) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(timestamp_tx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp_rx) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(timestamp_rx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conn) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(conn)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct csp_packet_s__bindgen_ty_1__bindgen_ty_2 {
    pub rx_count: u16,
    pub remain: u16,
    pub cfpid: u32,
    pub last_used: u32,
    pub frame_begin: *mut u8,
    pub frame_length: u16,
}
#[test]
fn bindgen_test_layout_csp_packet_s__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<csp_packet_s__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<csp_packet_s__bindgen_ty_1__bindgen_ty_2>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(csp_packet_s__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<csp_packet_s__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(csp_packet_s__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(rx_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).remain) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(remain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cfpid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(cfpid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_used) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(last_used)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_begin) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(frame_begin)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_length) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(frame_length)
        )
    );
}
#[test]
fn bindgen_test_layout_csp_packet_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<csp_packet_s__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(csp_packet_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<csp_packet_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(csp_packet_s__bindgen_ty_1))
    );
}
#[doc = " Data part of packet:"]
#[repr(C)]
#[derive(Copy, Clone)]
pub union csp_packet_s__bindgen_ty_2 {
    pub data: [u8; 2048usize],
    pub data16: [u16; 1024usize],
    pub data32: [u32; 512usize],
}
#[test]
fn bindgen_test_layout_csp_packet_s__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<csp_packet_s__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<csp_packet_s__bindgen_ty_2>(),
        2048usize,
        concat!("Size of: ", stringify!(csp_packet_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<csp_packet_s__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(csp_packet_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s__bindgen_ty_2),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data16) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s__bindgen_ty_2),
            "::",
            stringify!(data16)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data32) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s__bindgen_ty_2),
            "::",
            stringify!(data32)
        )
    );
}
#[test]
fn bindgen_test_layout_csp_packet_s() {
    const UNINIT: ::std::mem::MaybeUninit<csp_packet_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<csp_packet_s>(),
        2112usize,
        concat!("Size of: ", stringify!(csp_packet_s))
    );
    assert_eq!(
        ::std::mem::align_of::<csp_packet_s>(),
        8usize,
        concat!("Alignment of ", stringify!(csp_packet_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).id) as usize - ptr as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_packet_s),
            "::",
            stringify!(header)
        )
    );
}
#[doc = "CSP Packet.\n\nThis structure is constructed to fit with all interface and protocols to prevent the\nneed to copy data (zero copy).\n\n@note In most cases a CSP packet cannot be reused in case of send failure, because the\nlower layers may add additional data causing increased length (e.g. CRC32), convert\nthe CSP id to different endian (e.g. I2C), etc."]
pub type csp_packet_t = csp_packet_s;
#[doc = " Forward declaration of CSP interface, see #csp_iface_s for details."]
pub type csp_iface_t = csp_iface_s;
pub type csp_callback_t = ::std::option::Option<unsafe extern "C" fn(packet: *mut csp_packet_t)>;
#[doc = " @brief Connection struct"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct csp_socket_s {
    pub rx_queue: csp_queue_handle_t,
    pub rx_queue_static: csp_static_queue_t,
    pub rx_queue_static_data: [::std::os::raw::c_char; 8000usize],
    pub opts: u32,
}
#[test]
fn bindgen_test_layout_csp_socket_s() {
    const UNINIT: ::std::mem::MaybeUninit<csp_socket_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<csp_socket_s>(),
        8024usize,
        concat!("Size of: ", stringify!(csp_socket_s))
    );
    assert_eq!(
        ::std::mem::align_of::<csp_socket_s>(),
        8usize,
        concat!("Alignment of ", stringify!(csp_socket_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_queue) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_socket_s),
            "::",
            stringify!(rx_queue)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_queue_static) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_socket_s),
            "::",
            stringify!(rx_queue_static)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_queue_static_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_socket_s),
            "::",
            stringify!(rx_queue_static_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).opts) as usize - ptr as usize },
        8016usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_socket_s),
            "::",
            stringify!(opts)
        )
    );
}
#[doc = " @brief Connection struct"]
pub type csp_socket_t = csp_socket_s;
#[doc = " Forward declaration of connection structure"]
pub type csp_conn_t = csp_conn_s;
#[doc = " Memory pointer"]
pub type csp_memptr_t = *mut ::std::os::raw::c_void;
#[doc = " Const memory pointer"]
pub type csp_const_memptr_t = *const ::std::os::raw::c_void;
#[doc = "Platform specific memory copy function."]
pub type csp_memcpy_fnc_t = ::std::option::Option<
    unsafe extern "C" fn(arg1: csp_memptr_t, arg2: csp_const_memptr_t, arg3: usize) -> csp_memptr_t,
>;
extern "C" {
    #[doc = "Get free buffer (from task context).\n\n@param[in] data_size OBSOLETE ignored field, csp packets have a fixed size now\n@return Buffer (pointer to #csp_packet_t) or NULL if no buffers available"]
    pub fn csp_buffer_get(unused: usize) -> *mut csp_packet_t;
}
extern "C" {
    #[doc = "Get free buffer (from ISR context).\n\n@param[in] data_size OBSOLETE ignored field, csp packets have a fixed size now\n@return Buffer (pointer to #csp_packet_t) or NULL if no buffers available"]
    pub fn csp_buffer_get_isr(unused: usize) -> *mut csp_packet_t;
}
extern "C" {
    #[doc = "Free buffer (from task context).\n@param[in] buffer buffer to free. NULL is handled gracefully."]
    pub fn csp_buffer_free(buffer: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "Free buffer (from ISR context).\n@param[in] buffer buffer to free. NULL is handled gracefully."]
    pub fn csp_buffer_free_isr(buffer: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "Clone an existing buffer.\nThe existing \\a buffer content is copied to the new buffer.\n@param[in] buffer buffer to clone.\n@return cloned buffer on success, or NULL on failure."]
    pub fn csp_buffer_clone(buffer: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    #[doc = "Return number of remaining/free buffers.\nThe number of buffers is set by csp_init().\n@return number of remaining/free buffers"]
    pub fn csp_buffer_remaining() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn csp_buffer_init();
}
#[doc = " Interface Tx function.\n @return #CSP_ERR_NONE on success, otherwise an error code."]
pub type nexthop_t = ::std::option::Option<
    unsafe extern "C" fn(
        iface: *mut csp_iface_t,
        via: u16,
        packet: *mut csp_packet_t,
        from_me: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct csp_iface_s {
    pub addr: u16,
    pub netmask: u16,
    pub name: *const ::std::os::raw::c_char,
    pub interface_data: *mut ::std::os::raw::c_void,
    pub driver_data: *mut ::std::os::raw::c_void,
    pub nexthop: nexthop_t,
    pub split_horizon_off: u8,
    pub tx: u32,
    pub rx: u32,
    pub tx_error: u32,
    pub rx_error: u32,
    pub drop: u32,
    pub autherr: u32,
    pub frame: u32,
    pub txbytes: u32,
    pub rxbytes: u32,
    pub irq: u32,
    pub next: *mut csp_iface_s,
}
#[test]
fn bindgen_test_layout_csp_iface_s() {
    const UNINIT: ::std::mem::MaybeUninit<csp_iface_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<csp_iface_s>(),
        96usize,
        concat!("Size of: ", stringify!(csp_iface_s))
    );
    assert_eq!(
        ::std::mem::align_of::<csp_iface_s>(),
        8usize,
        concat!("Alignment of ", stringify!(csp_iface_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).netmask) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(netmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).interface_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(interface_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).driver_data) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(driver_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nexthop) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(nexthop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).split_horizon_off) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(split_horizon_off)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(tx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(rx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_error) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(tx_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_error) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(rx_error)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).drop) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(drop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).autherr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(autherr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).txbytes) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(txbytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rxbytes) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(rxbytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).irq) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(irq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).next) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_iface_s),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    #[doc = "Inputs a new packet into the system.\n\nThis function can be called from interface drivers (ISR) or tasks, to route and accept packets.\n\n@note EXTREMELY IMPORTANT: \\a pxTaskWoken must ALWAYS be NULL if called from task, and ALWAYS\nbe NON NULL if called from ISR. If this condition is met, this call is completely thread-safe\n\nThis function is fire and forget, it returns void, meaning that the \\a packet will always be\neither accepted or dropped, so the memory will always be freed.\n\n@param[in] packet A pointer to the incoming packet\n@param[in] iface A pointer to the incoming interface TX function.\n@param[out] pxTaskWoken Valid reference if called from ISR, otherwise NULL!"]
    pub fn csp_qfifo_write(
        packet: *mut csp_packet_t,
        iface: *mut csp_iface_t,
        pxTaskWoken: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = "Add interface to the list.\n\n@param[in] iface interface. The interface must remain valid as long as the application is running.\n@return #CSP_ERR_NONE on success, otherwise an error code."]
    pub fn csp_iflist_add(iface: *mut csp_iface_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn csp_iflist_get_by_name(name: *const ::std::os::raw::c_char) -> *mut csp_iface_t;
}
extern "C" {
    pub fn csp_iflist_get_by_addr(addr: u16) -> *mut csp_iface_t;
}
extern "C" {
    pub fn csp_iflist_get_by_subnet(addr: u16, from: *mut csp_iface_t) -> *mut csp_iface_t;
}
extern "C" {
    pub fn csp_iflist_get_by_index(idx: ::std::os::raw::c_int) -> *mut csp_iface_t;
}
extern "C" {
    pub fn csp_iflist_is_within_subnet(addr: u16, ifc: *mut csp_iface_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn csp_iflist_get() -> *mut csp_iface_t;
}
extern "C" {
    pub fn csp_iflist_set_default(interface: *mut csp_iface_t);
}
extern "C" {
    pub fn csp_iflist_get_default() -> *mut csp_iface_t;
}
extern "C" {
    pub fn csp_bytesize(
        bytes: ::std::os::raw::c_ulong,
        postfix: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn csp_iflist_print();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct csp_route_s {
    pub address: u16,
    pub netmask: u16,
    pub via: u16,
    pub iface: *mut csp_iface_t,
}
#[test]
fn bindgen_test_layout_csp_route_s() {
    const UNINIT: ::std::mem::MaybeUninit<csp_route_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<csp_route_s>(),
        16usize,
        concat!("Size of: ", stringify!(csp_route_s))
    );
    assert_eq!(
        ::std::mem::align_of::<csp_route_s>(),
        8usize,
        concat!("Alignment of ", stringify!(csp_route_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_route_s),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).netmask) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_route_s),
            "::",
            stringify!(netmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).via) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_route_s),
            "::",
            stringify!(via)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).iface) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_route_s),
            "::",
            stringify!(iface)
        )
    );
}
pub type csp_route_t = csp_route_s;
extern "C" {
    pub fn csp_rtable_find_route(dest_address: u16) -> *mut csp_route_t;
}
extern "C" {
    #[doc = "Set route to destination address/node.\n@param[in] dest_address destination address.\n@param[in] mask number of bits in netmask (set to -1 for maximum number of bits)\n@param[in] ifc interface.\n@param[in] via assosicated via address.\n@return #CSP_ERR_NONE on success, or an error code."]
    pub fn csp_rtable_set(
        dest_address: u16,
        netmask: ::std::os::raw::c_int,
        ifc: *mut csp_iface_t,
        via: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Save routing table as a string (readable format).\n@see csp_rtable_load() for additional information, e.g. format.\n@param[out] buffer user supplied buffer.\n@param[in] buffer_size size of \\a buffer.\n@return #CSP_ERR_NONE on success, or an error code."]
    pub fn csp_rtable_save(
        buffer: *mut ::std::os::raw::c_char,
        buffer_size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Load routing table from a string.\nTable will be loaded on-top of existing routes, possibly overwriting existing entries.\nFormat: \\<address\\>[/mask] \\<interface\\> [via][, next entry]\nExample: \"0/0 CAN, 8 KISS, 10 I2C 10\", same as \"0/0 CAN, 8/5 KISS, 10/5 I2C 10\".\n@see csp_rtable_save(), csp_rtable_clear(), csp_rtable_free()\n@param[in] rtable routing table (nul terminated)\n@return @ref CSP_ERR or number of entries."]
    pub fn csp_rtable_load(rtable: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Check string for valid routing elements.\n@param[in] rtable routing table (nul terminated)\n@return @ref CSP_ERR or number of entries."]
    pub fn csp_rtable_check(rtable: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Clear routing table and add loopback route.\n@see csp_rtable_free()"]
    pub fn csp_rtable_clear();
}
extern "C" {
    #[doc = "Clear/free all entries in the routing table."]
    pub fn csp_rtable_free();
}
#[doc = " Iterator for looping through the routing table."]
pub type csp_rtable_iterator_t = ::std::option::Option<
    unsafe extern "C" fn(ctx: *mut ::std::os::raw::c_void, route: *mut csp_route_t) -> bool,
>;
extern "C" {
    #[doc = "Iterate routing table."]
    pub fn csp_rtable_iterate(iter: csp_rtable_iterator_t, ctx: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "Print routing table"]
    pub fn csp_rtable_print();
}
extern "C" {
    pub fn memcpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memmove(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memccpy(
        __dest: *mut ::std::os::raw::c_void,
        __src: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memset(
        __s: *mut ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn memcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __memcmpeq(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn memchr(
        __s: *const ::std::os::raw::c_void,
        __c: ::std::os::raw::c_int,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn strcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strncat(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcoll(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_ulong;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    const UNINIT: ::std::mem::MaybeUninit<__locale_struct> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__locales) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_b) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_tolower) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctype_toupper) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__names) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strcoll_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __l: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strxfrm_l(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
        __l: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn strdup(__s: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strndup(
        __string: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strrchr(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strcspn(
        __s: *const ::std::os::raw::c_char,
        __reject: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strspn(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strpbrk(
        __s: *const ::std::os::raw::c_char,
        __accept: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strstr(
        __haystack: *const ::std::os::raw::c_char,
        __needle: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strtok_r(
        __s: *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
        __save_ptr: *mut *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strlen(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strnlen(__string: *const ::std::os::raw::c_char, __maxlen: usize) -> usize;
}
extern "C" {
    pub fn strerror(__errnum: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}__xpg_strerror_r"]
    pub fn strerror_r(
        __errnum: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strerror_l(
        __errnum: ::std::os::raw::c_int,
        __l: locale_t,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn bcmp(
        __s1: *const ::std::os::raw::c_void,
        __s2: *const ::std::os::raw::c_void,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn bcopy(
        __src: *const ::std::os::raw::c_void,
        __dest: *mut ::std::os::raw::c_void,
        __n: usize,
    );
}
extern "C" {
    pub fn bzero(__s: *mut ::std::os::raw::c_void, __n: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn index(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn rindex(
        __s: *const ::std::os::raw::c_char,
        __c: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ffs(__i: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsl(__l: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ffsll(__ll: ::std::os::raw::c_longlong) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strcasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strncasecmp_l(
        __s1: *const ::std::os::raw::c_char,
        __s2: *const ::std::os::raw::c_char,
        __n: usize,
        __loc: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn explicit_bzero(__s: *mut ::std::os::raw::c_void, __n: usize);
}
extern "C" {
    pub fn strsep(
        __stringp: *mut *mut ::std::os::raw::c_char,
        __delim: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn strsignal(__sig: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpcpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn stpncpy(
        __dest: *mut ::std::os::raw::c_char,
        __src: *const ::std::os::raw::c_char,
        __n: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_char;
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos_t = _G_fpos_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    const UNINIT: ::std::mem::MaybeUninit<_G_fpos64_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pos) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__state) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type __fpos64_t = _G_fpos64_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    const UNINIT: ::std::mem::MaybeUninit<_IO_FILE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_ptr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_end) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_read_base) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_base) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_ptr) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_write_end) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_base) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_buf_end) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_base) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_backup_base) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._IO_save_end) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._markers) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._chain) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._fileno) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._old_offset) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._cur_column) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._vtable_offset) as usize - ptr as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._shortbuf) as usize - ptr as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._codecvt) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_codecvt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._wide_data) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_wide_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_list) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._freeres_buf) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_freeres_buf)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad5) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mode) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._unused2) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
pub type off_t = __off_t;
pub type fpos_t = __fpos_t;
extern "C" {
    pub static mut stdin: *mut FILE;
}
extern "C" {
    pub static mut stdout: *mut FILE;
}
extern "C" {
    pub static mut stderr: *mut FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: ::std::os::raw::c_ulong,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __stream: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
        __n: ::std::os::raw::c_ulong,
        __s: *mut FILE,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn __uflow(arg1: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc(__size: ::std::os::raw::c_ulong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        __nmemb: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        __ptr: *mut ::std::os::raw::c_void,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn reallocarray(
        __ptr: *mut ::std::os::raw::c_void,
        __nmemb: usize,
        __size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn memalign(
        __alignment: ::std::os::raw::c_ulong,
        __size: ::std::os::raw::c_ulong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pvalloc(__size: usize) -> *mut ::std::os::raw::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mallinfo {
    pub arena: ::std::os::raw::c_int,
    pub ordblks: ::std::os::raw::c_int,
    pub smblks: ::std::os::raw::c_int,
    pub hblks: ::std::os::raw::c_int,
    pub hblkhd: ::std::os::raw::c_int,
    pub usmblks: ::std::os::raw::c_int,
    pub fsmblks: ::std::os::raw::c_int,
    pub uordblks: ::std::os::raw::c_int,
    pub fordblks: ::std::os::raw::c_int,
    pub keepcost: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_mallinfo() {
    const UNINIT: ::std::mem::MaybeUninit<mallinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mallinfo>(),
        40usize,
        concat!("Size of: ", stringify!(mallinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<mallinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(mallinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arena) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(arena)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ordblks) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(ordblks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).smblks) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(smblks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hblks) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(hblks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hblkhd) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(hblkhd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usmblks) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(usmblks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fsmblks) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(fsmblks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uordblks) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(uordblks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fordblks) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(fordblks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keepcost) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo),
            "::",
            stringify!(keepcost)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mallinfo2 {
    pub arena: usize,
    pub ordblks: usize,
    pub smblks: usize,
    pub hblks: usize,
    pub hblkhd: usize,
    pub usmblks: usize,
    pub fsmblks: usize,
    pub uordblks: usize,
    pub fordblks: usize,
    pub keepcost: usize,
}
#[test]
fn bindgen_test_layout_mallinfo2() {
    const UNINIT: ::std::mem::MaybeUninit<mallinfo2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<mallinfo2>(),
        80usize,
        concat!("Size of: ", stringify!(mallinfo2))
    );
    assert_eq!(
        ::std::mem::align_of::<mallinfo2>(),
        8usize,
        concat!("Alignment of ", stringify!(mallinfo2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).arena) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(arena)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ordblks) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(ordblks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).smblks) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(smblks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hblks) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(hblks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hblkhd) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(hblkhd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usmblks) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(usmblks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fsmblks) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(fsmblks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uordblks) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(uordblks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fordblks) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(fordblks)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).keepcost) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(mallinfo2),
            "::",
            stringify!(keepcost)
        )
    );
}
extern "C" {
    pub fn mallinfo() -> mallinfo;
}
extern "C" {
    pub fn mallinfo2() -> mallinfo2;
}
extern "C" {
    pub fn mallopt(
        __param: ::std::os::raw::c_int,
        __val: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc_trim(__pad: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn malloc_usable_size(__ptr: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn malloc_stats();
}
extern "C" {
    pub fn malloc_info(__options: ::std::os::raw::c_int, __fp: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Send data over a CSP connection.\n\nData will be send in chunks of \\a mtu bytes. The MTU must be small enough to fit into a CSP packat + SFP header + other transport headers.\n\ncsp_sfp_recv() or csp_sfp_recv_fp() can be used at the other end to receive data.\n\nThis is usefull if you wish to send data stored in flash memory or another location, where standard memcpy() doesn't work.\n\n@param[in] conn established connection for sending SFP packets.\n@param[in] data data to send\n@param[in] datasize size of \\a data\n@param[in] mtu maximum transfer unit (bytes), max data chunk to send.\n@param[in] timeout unused as of CSP version 1.6\n@param[in] memcpyfcn memory copy function.\n@return #CSP_ERR_NONE on success, otherwise an error."]
    pub fn csp_sfp_send_own_memcpy(
        conn: *mut csp_conn_t,
        data: *const ::std::os::raw::c_void,
        datasize: ::std::os::raw::c_uint,
        mtu: ::std::os::raw::c_uint,
        timeout: u32,
        memcpyfcn: csp_memcpy_fnc_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Receive data over a CSP connection.\n\nThis is the counterpart to the csp_sfp_send() and csp_sfp_send_own_memcpy().\n\n@param[in] conn established connection for receiving SFP packets.\n@param[out] dataout received data on success. Allocated with malloc(), so should be freed with free(). The pointer will be NULL on failure.\n@param[out] datasize size of received data.\n@param[in] timeout timeout in ms to wait for csp_read()\n@param[in] first_packet First packet of a SFP transfer. Use NULL to receive first packet on the connection.\n@return #CSP_ERR_NONE on success, otherwise an error."]
    pub fn csp_sfp_recv_fp(
        conn: *mut csp_conn_t,
        dataout: *mut *mut ::std::os::raw::c_void,
        datasize: *mut ::std::os::raw::c_int,
        timeout: u32,
        first_packet: *mut csp_packet_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn free_sfp(c: *mut ::std::os::raw::c_void);
}
extern "C" {
    #[doc = "Enable promiscuous packet queue.\n@param[in] queue_size Size (max length) of queue for incoming packets.\n@return #CSP_ERR_NONE on success, otherwise an error code."]
    pub fn csp_promisc_enable(queue_size: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Disable promiscuous mode."]
    pub fn csp_promisc_disable();
}
extern "C" {
    #[doc = "Get/dequeue packet from promiscuous packet queue.\n\nReturns the first packet from the promiscuous packet queue.\n@param[in] timeout Timeout in ms to wait for a packet.\n@return Packet (free with csp_buffer_free() or re-use packet), NULL on error or timeout."]
    pub fn csp_promisc_read(timeout: u32) -> *mut csp_packet_t;
}
#[doc = "< Deduplication off"]
pub const csp_dedup_types_CSP_DEDUP_OFF: csp_dedup_types = 0;
#[doc = "< Deduplication on forwarding only"]
pub const csp_dedup_types_CSP_DEDUP_FWD: csp_dedup_types = 1;
#[doc = "< Deduplication on incomfing only"]
pub const csp_dedup_types_CSP_DEDUP_INCOMING: csp_dedup_types = 2;
#[doc = "< Deduplication on incoming and forwarding"]
pub const csp_dedup_types_CSP_DEDUP_ALL: csp_dedup_types = 3;
pub type csp_dedup_types = ::std::os::raw::c_uint;
#[doc = "CSP configuration."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct csp_conf_s {
    #[doc = "< Protocol version to use (either 1 or 2)"]
    pub version: u8,
    #[doc = "< Host name, returned by the #CSP_CMP_IDENT request"]
    pub hostname: *const ::std::os::raw::c_char,
    #[doc = "< Model, returned by the #CSP_CMP_IDENT request"]
    pub model: *const ::std::os::raw::c_char,
    #[doc = "< Revision, returned by the #CSP_CMP_IDENT request"]
    pub revision: *const ::std::os::raw::c_char,
    #[doc = "< Default connection options. Options will always be or'ed onto new connections, see csp_connect()"]
    pub conn_dfl_so: u32,
    #[doc = "< Enable CSP deduplication. 0 = off, 1 = always on, 2 = only on forwarded packets,"]
    pub dedup: u8,
}
#[test]
fn bindgen_test_layout_csp_conf_s() {
    const UNINIT: ::std::mem::MaybeUninit<csp_conf_s> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<csp_conf_s>(),
        40usize,
        concat!("Size of: ", stringify!(csp_conf_s))
    );
    assert_eq!(
        ::std::mem::align_of::<csp_conf_s>(),
        8usize,
        concat!("Alignment of ", stringify!(csp_conf_s))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_conf_s),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hostname) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_conf_s),
            "::",
            stringify!(hostname)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).model) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_conf_s),
            "::",
            stringify!(model)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).revision) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_conf_s),
            "::",
            stringify!(revision)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).conn_dfl_so) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_conf_s),
            "::",
            stringify!(conn_dfl_so)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dedup) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(csp_conf_s),
            "::",
            stringify!(dedup)
        )
    );
}
#[doc = "CSP configuration."]
pub type csp_conf_t = csp_conf_s;
extern "C" {
    pub static mut csp_conf: csp_conf_t;
}
extern "C" {
    #[doc = " Initialize CSP.\n This will configure basic structures."]
    pub fn csp_init();
}
extern "C" {
    #[doc = "Free allocated resorces in CSP.\nThis is intended for testing of CSP, in order to be able re-initialize CSP by calling csp_init() again."]
    pub fn csp_free_resources();
}
extern "C" {
    #[doc = "Get a \\a read-only reference to the active CSP configuration.\n@return Active CSP configuration (read-only)."]
    pub fn csp_get_conf() -> *const csp_conf_t;
}
extern "C" {
    #[doc = " Copy csp id fields from source to target object"]
    pub fn csp_id_copy(target: *mut csp_id_t, source: *mut csp_id_t);
}
extern "C" {
    #[doc = "Wait/accept a new connection.\n@param[in] socket socket to accept connections on, created by calling csp_socket().\n@param[in] timeout timeout in mS to wait for a connection, use #CSP_MAX_TIMEOUT for infinite timeout.\n@return New connection on success, NULL on failure or timeout."]
    pub fn csp_accept(socket: *mut csp_socket_t, timeout: u32) -> *mut csp_conn_t;
}
extern "C" {
    #[doc = "Read packet from a connection.\nThis fuction will wait on the connection's RX queue for the specified timeout.\n@param[in] conn connection\n@param[in] timeout timeout in mS to wait for a packet, use #CSP_MAX_TIMEOUT for infinite timeout.\n@return Packet or NULL in case of failure or timeout."]
    pub fn csp_read(conn: *mut csp_conn_t, timeout: u32) -> *mut csp_packet_t;
}
extern "C" {
    #[doc = "Send packet on a connection.\n\nThe packet buffer is automatically freed, and cannot be used after the call to csp_send()\n\n@param[in] conn connection\n@param[in] packet packet to send"]
    pub fn csp_send(conn: *mut csp_conn_t, packet: *mut csp_packet_t);
}
extern "C" {
    #[doc = "Change the default priority of the connection and send a packet.\n@note The priority of the connection will be changed. If you need to change it back, call csp_send_prio() again.\n\n@param[in] prio priority to set on the connection\n@param[in] conn connection\n@param[in] packet packet to send"]
    pub fn csp_send_prio(prio: u8, conn: *mut csp_conn_t, packet: *mut csp_packet_t);
}
extern "C" {
    #[doc = "Perform an entire request & reply transaction.\nCreates a connection, send \\a outbuf, wait for reply, copy reply to \\a inbuf and close the connection.\n@param[in] prio priority, see #csp_prio_t\n@param[in] dst destination address\n@param[in] dst_port destination port\n@param[in] timeout timeout in mS to wait for a reply\n@param[in] outbuf outgoing data (request)\n@param[in] outlen length of data in \\a outbuf (request)\n@param[out] inbuf user provided buffer for receiving data (reply)\n@param[in] inlen length of expected reply, -1 for unknown size (inbuf MUST be large enough), 0 for no reply.\n@param[in] opts connection options, see @ref CSP_CONNECTION_OPTIONS.\n@return 1 or reply size on success, 0 on failure (error, incoming length does not match, timeout)"]
    pub fn csp_transaction_w_opts(
        prio: u8,
        dst: u16,
        dst_port: u8,
        timeout: u32,
        outbuf: *mut ::std::os::raw::c_void,
        outlen: ::std::os::raw::c_int,
        inbuf: *mut ::std::os::raw::c_void,
        inlen: ::std::os::raw::c_int,
        opts: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Perform an entire request & reply transaction on an existing connection.\nSend \\a outbuf, wait for reply and copy reply to \\a inbuf.\n@param[in] conn connection\n@param[in] timeout timeout in mS to wait for a reply\n@param[in] outbuf outgoing data (request)\n@param[in] outlen length of data in \\a outbuf (request)\n@param[out] inbuf user provided buffer for receiving data (reply)\n@param[in] inlen length of expected reply, -1 for unknown size (inbuf MUST be large enough), 0 for no reply.\n@return 1 or reply size on success, 0 on failure (error, incoming length does not match, timeout)"]
    pub fn csp_transaction_persistent(
        conn: *mut csp_conn_t,
        timeout: u32,
        outbuf: *mut ::std::os::raw::c_void,
        outlen: ::std::os::raw::c_int,
        inbuf: *mut ::std::os::raw::c_void,
        inlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Read data from a connection-less server socket.\n@param[in] socket connection-less socket.\n@param[in] timeout timeout in mS to wait for a packet, use #CSP_MAX_TIMEOUT for infinite timeout.\n@return Packet on success, or NULL on failure or timeout."]
    pub fn csp_recvfrom(socket: *mut csp_socket_t, timeout: u32) -> *mut csp_packet_t;
}
extern "C" {
    #[doc = "Send a packet (without connection).\n@param[in] prio packet priority, see #csp_prio_t\n@param[in] dst destination address\n@param[in] dst_port destination port\n@param[in] src_port source port\n@param[in] opts connection options, see @ref CSP_CONNECTION_OPTIONS.\n@param[in] packet packet to send"]
    pub fn csp_sendto(
        prio: u8,
        dst: u16,
        dst_port: u8,
        src_port: u8,
        opts: u32,
        packet: *mut csp_packet_t,
    );
}
extern "C" {
    #[doc = "Send a packet as a reply to a request (without a connection).\nCalls csp_sendto() with the source address and port from the request.\n@param[in] request incoming request\n@param[in] reply reply packet\n@param[in] opts connection options, see @ref CSP_CONNECTION_OPTIONS."]
    pub fn csp_sendto_reply(request: *const csp_packet_t, reply: *mut csp_packet_t, opts: u32);
}
extern "C" {
    #[doc = "Establish outgoing connection.\nThe call will return immediately, unless it is a RDP connection (#CSP_O_RDP) in which case it will wait until the other\nend acknowleges the connection (timeout is determined by the current connection timeout set by csp_rdp_set_opt()).\n@param[in] prio priority, see #csp_prio_t\n@param[in] dst Destination address\n@param[in] dst_port Destination port\n@param[in] timeout unused.\n@param[in] opts connection options, see @ref CSP_CONNECTION_OPTIONS.\n@return Established connection or NULL on failure (no free connections, timeout)."]
    pub fn csp_connect(
        prio: u8,
        dst: u16,
        dst_port: u8,
        timeout: u32,
        opts: u32,
    ) -> *mut csp_conn_t;
}
extern "C" {
    #[doc = "Close an open connection.\nAny packets in the RX queue will be freed.\n@param[in] conn connection. Closing a NULL connection is acceptable.\n@return #CSP_ERR_NONE on success, otherwise an error code."]
    pub fn csp_close(conn: *mut csp_conn_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Return destination port of connection.\n@param[in] conn connection\n@return destination port of an incoming connection"]
    pub fn csp_conn_dport(conn: *mut csp_conn_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Return source port of connection.\n@param conn connection\n@return source port of an incoming connection"]
    pub fn csp_conn_sport(conn: *mut csp_conn_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Return destination address of connection.\n@param[in] conn connection\n@return destination address of an incoming connection"]
    pub fn csp_conn_dst(conn: *mut csp_conn_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Return source address of connection.\n@param conn connection\n@return source address of an incoming connection"]
    pub fn csp_conn_src(conn: *mut csp_conn_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Return flags of connection.\n@param[in] conn connection\n@return flags of an incoming connection, see @ref CSP_HEADER_FLAGS"]
    pub fn csp_conn_flags(conn: *mut csp_conn_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Set socket to listen for incoming connections.\n@param[in] socket socket\n@param[in] backlog max length of backlog queue. The backlog queue holds incoming connections, waiting to be returned by call to csp_accept().\n@return #CSP_ERR_NONE on success, otherwise an error code."]
    pub fn csp_listen(socket: *mut csp_socket_t, backlog: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Bind port to socket.\n@param[in] socket socket to bind port to\n@param[in] port port number to bind, use #CSP_ANY for all ports. Bindnig to a specific will take precedence over #CSP_ANY.\n@return #CSP_ERR_NONE on success, otherwise an error code."]
    pub fn csp_bind(socket: *mut csp_socket_t, port: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Bind port to callback function.\n@param[in] callback pointer to callback function\n@param[in] port port number to bind, use #CSP_ANY for all ports. Bindnig to a specific will take precedence over #CSP_ANY.\n@return 0 on success, otherwise an error code."]
    pub fn csp_bind_callback(callback: csp_callback_t, port: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Route packet from the incoming router queue and check RDP timeouts.\nIn order for incoming packets to routed and RDP timeouts to be checked, this function must be called reguarly.\n@return #CSP_ERR_NONE on success, otherwise an error code."]
    pub fn csp_route_work() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Set the bridge interfaces."]
    pub fn csp_bridge_set_interfaces(if_a: *mut csp_iface_t, if_b: *mut csp_iface_t);
}
extern "C" {
    #[doc = "Bridge packet from an interface to the other."]
    pub fn csp_bridge_work();
}
extern "C" {
    #[doc = "Handle CSP service request.\nIf the given packet is a service-request (the destination port matches one of CSP service ports #csp_service_port_t),\nthe packet will be processed by the specific CSP service handler.\nThe packet will either process it or free it, so this function is typically called in the last \"default\" clause of\na switch/case statement in a CSP listener task.\nIn order to listen to csp service ports, bind your listener to the specific services ports #csp_service_port_t or\nuse #CSP_ANY to all ports.\n@param[in] packet first packet, obtained by using csp_read()"]
    pub fn csp_service_handler(packet: *mut csp_packet_t);
}
extern "C" {
    #[doc = "Send a single ping/echo packet.\n@param[in] node address of subsystem.\n@param[in] timeout timeout in ms to wait for reply.\n@param[in] size payload size in bytes.\n@param[in] opts connection options, see @ref CSP_CONNECTION_OPTIONS.\n@return >0 = echo time in mS on success, otherwise -1 for error."]
    pub fn csp_ping(
        node: u16,
        timeout: u32,
        size: ::std::os::raw::c_uint,
        opts: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Send a single ping/echo packet without waiting for reply.\nPayload is 1 byte.\n@param[in] node address of subsystem."]
    pub fn csp_ping_noreply(node: u16);
}
extern "C" {
    #[doc = "Request process list.\n@note This is currently only supported on FreeRTOS systems.\n@param[in] node address of subsystem.\n@param[in] timeout timeout in mS to wait for replies. The function will not return until the timeout occurrs."]
    pub fn csp_ps(node: u16, timeout: u32);
}
extern "C" {
    #[doc = "Request free memory.\n@param[in] node address of subsystem.\n@param[in] timeout timeout in mS to wait for reply.\n@param[out] size free memory on subsystem.\n@return #CSP_ERR_NONE on success, otherwise an error code."]
    pub fn csp_get_memfree(node: u16, timeout: u32, size: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Request free memory and print to stdout.\n@param[in] node address of subsystem.\n@param[in] timeout timeout in mS to wait for reply."]
    pub fn csp_memfree(node: u16, timeout: u32);
}
extern "C" {
    #[doc = "Request free buffers.\n@param[in] node address of subsystem.\n@param[in] timeout timeout in mS to wait for reply.\n@param[out] size free buffers.\n@return #CSP_ERR_NONE on success, otherwise an error code."]
    pub fn csp_get_buf_free(node: u16, timeout: u32, size: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Request free buffers and print to stdout.\n@param[in] node address of subsystem.\n@param[in] timeout timeout in mS to wait for reply."]
    pub fn csp_buf_free(node: u16, timeout: u32);
}
extern "C" {
    #[doc = "Reboot subsystem.\nIf handled by the standard CSP service handler, the reboot handler set by csp_sys_set_reboot() on the subsystem, will be invoked.\n@param[in] node address of subsystem."]
    pub fn csp_reboot(node: u16);
}
extern "C" {
    #[doc = "Shutdown subsystem.\nIf handled by the standard CSP service handler, the shutdown handler set by csp_sys_set_shutdown() on the subsystem, will be invoked.\n@param[in] node address of subsystem."]
    pub fn csp_shutdown(node: u16);
}
extern "C" {
    #[doc = "Request uptime and print to stdout.\n@param[in] node address of subsystem.\n@param[in] timeout timeout in mS to wait for reply."]
    pub fn csp_uptime(node: u16, timeout: u32);
}
extern "C" {
    #[doc = "Request uptime\n@param[in] node address of subsystem.\n@param[in] timeout timeout in mS to wait for reply.\n@param[out] uptime uptime in seconds.\n@return #CSP_ERR_NONE on success, otherwise an error code."]
    pub fn csp_get_uptime(node: u16, timeout: u32, uptime: *mut u32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "Set RDP options.\nThe RDP options are used from the connecting/client side. When a RDP connection is established, the client tranmits the options to the server.\n@param[in] window_size window size\n@param[in] conn_timeout_ms connection timeout in mS\n@param[in] packet_timeout_ms packet timeout in mS.\n@param[in] delayed_acks enable/disable delayed acknowledgements.\n@param[in] ack_timeout acknowledgement timeout when delayed ACKs is enabled\n@param[in] ack_delay_count send acknowledgement for every ack_delay_count packets."]
    pub fn csp_rdp_set_opt(
        window_size: ::std::os::raw::c_uint,
        conn_timeout_ms: ::std::os::raw::c_uint,
        packet_timeout_ms: ::std::os::raw::c_uint,
        delayed_acks: ::std::os::raw::c_uint,
        ack_timeout: ::std::os::raw::c_uint,
        ack_delay_count: ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = "Get RDP options.\n@see csp_rdp_set_opt()\n@param[out] window_size Window size\n@param[out] conn_timeout_ms connection timeout in ms\n@param[out] packet_timeout_ms packet timeout in ms\n@param[out] delayed_acks enable/disable delayed acknowledgements\n@param[out] ack_timeout acknowledgement timeout when delayed ACKs is enabled\n@param[out] ack_delay_count send acknowledgement for every ack_delay_count packets"]
    pub fn csp_rdp_get_opt(
        window_size: *mut ::std::os::raw::c_uint,
        conn_timeout_ms: *mut ::std::os::raw::c_uint,
        packet_timeout_ms: *mut ::std::os::raw::c_uint,
        delayed_acks: *mut ::std::os::raw::c_uint,
        ack_timeout: *mut ::std::os::raw::c_uint,
        ack_delay_count: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    #[doc = "Set platform specific memory copy function."]
    pub fn csp_cmp_set_memcpy(fnc: csp_memcpy_fnc_t);
}
extern "C" {
    #[doc = "Print connection table to stdout."]
    pub fn csp_conn_print_table();
}
extern "C" {
    #[doc = "Hex dump memory to stdout.\n@param[in] desc description printed on first line.\n@param[in] addr memory address.\n@param[in] len number of bytes to dump, starting from \\a addr."]
    pub fn csp_hex_dump(
        desc: *const ::std::os::raw::c_char,
        addr: *mut ::std::os::raw::c_void,
        len: ::std::os::raw::c_int,
    );
}
extern "C" {
    #[doc = "Print connection table to string."]
    pub fn csp_conn_print_table_str(
        str_buf: *mut ::std::os::raw::c_char,
        str_size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct csp_conn_s {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    const UNINIT: ::std::mem::MaybeUninit<__va_list_tag> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gp_offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).fp_offset) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overflow_arg_area) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reg_save_area) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
